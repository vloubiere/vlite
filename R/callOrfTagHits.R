#' ORFtrap_call_hits
#'
#' @description Function to call hits from a given screen. Receives sorted and unsorted counts as input, computes FC table
#'
#' @param sorted.forward.counts Character vector of sorted (FACSed) count file paths generated by vl_ORFtag_pipeline().
#' Counts from all provided files will be merged.
#' @param unsorted.forward.counts Character vector of unsorted (input) count file paths generated by vl_ORFtag_pipeline().
#' Counts from all provided files will be merged.
#' @param sorted.reverse.counts If specified together with unsorted.reverse.counts, enrichments will also be computed using
#' reversed insertions and the result will be added in additional '.rev' columns (useful to detect insertion traps).
#' @param unsorted.reverse.counts If specified together with sorted.reverse.counts, enrichments will also be computed
#' using reversed insertions and the result will be added in additional '.rev' columns (useful to detect insertion traps).
#' @param genome Genome annotation to be used.
#' For now, only "mm10" and "hg38" are supported, and the corresponding non-first-exon .gtf will be used for sorting.
#' @param output.prefix Prefix used for output file names.
#' @param padj.cutoff The p.adjust cutoff to be used to call hits (>=). Default= 0.001
#' @param log2OR.cutoff The log2OR cutoff to be used to call hits (>=). Default= 1
#' @param log2OR.pseudocount Pseudocount used to avoid infinite values. Note that only the log2OR will be affected, not the fisher
#' p.values. Default= 0.5.
#' @param min.ins.cov.unsorted Minimum number of duplication counts for an insertion to be considered TRUE in the unsorted sample.
#' Default= 0 (no filtering).
#' @param min.ins.cov.sorted Minimum number of duplication counts for an insertion to be considered TRUE in the sorted sample.
#' Default= 0 (no filtering).
#' @param output.folder Output folder for FC files. Default= "db/FC_tables/ORFtag".
#' @param bed.output.folder Output folder where the bed files containing usable insertions on + and - strands will be saved.
#' By default, it will be saved in a 'bed/, sub-folder within the output folder.
#'
#' @return Returns FC tables containing DESeq2-like columns.
#'
#' @examples
#' # Call hits ----
#' # 124 hits should be identified with this dataset
#' callOrftagHits(sorted.forward.counts = c("db/gene_assignment/Activator2_sort_rep1_same_strand.txt",
#'                                          "db/gene_assignment/Activator2_sort_rep2_same_strand.txt"),
#'                unsorted.forward.counts = c("db/gene_assignment/Activator2_input_rep1_same_strand.txt",
#'                                            "db/gene_assignment/Activator2_input_rep2_same_strand.txt"),
#'                sorted.reverse.counts = c("db/gene_assignment/Activator2_sort_rep1_rev_strand.txt",
#'                                          "db/gene_assignment/Activator2_sort_rep2_rev_strand.txt"),
#'                unsorted.reverse.counts = c("db/gene_assignment/Activator2_input_rep1_rev_strand.txt",
#'                                            "db/gene_assignment/Activator2_input_rep2_rev_strand.txt"),
#'                genome = "mm10",
#'                output.prefix = "Activator_2_vs_input",
#'                output.folder = "/scratch-cbe/users/vincent.loubiere/")
#'
#' # To call hits using strand bias (not used)
#' see ?callOrftagHits_strandBias()
#'
#' @export
callOrftagHits <- function(
    sorted.forward.counts,
    unsorted.forward.counts,
    sorted.reverse.counts= NULL,
    unsorted.reverse.counts= NULL,
    genome,
    output.prefix,
    padj.cutoff= 0.001,
    log2OR.cutoff= 1,
    log2OR.pseudocount= 0.5,
    min.ins.cov.sorted= 0,
    min.ins.cov.unsorted= 0,
    output.folder= "db/FC_tables/ORFtag/",
    bed.output.folder= paste0(output.folder, "/bed/")
)
{
  # Load packages
  require(rtracklayer)
  require(data.table)
  require(GenomicRanges)

  # Checks ----
  if(!is.character(output.prefix) | length(output.prefix)!=1)
    stop("output.prefix should be a unique character, typically the name of the screen + comparison.")

  # Create output file names ----
  dir.create(output.folder, showWarnings = F, recursive = T)
  dir.create(bed.output.folder, showWarnings = F, recursive = T)
  output.file <- file.path(output.folder, paste0(output.prefix, ".txt"))
  output.pdf <- file.path(output.folder, paste0(output.prefix, ".pdf"))

  # Import gene exons ----
  gtf <- switch(genome,
                "mm10" = "/groups/stark/vloubiere/projects/ORFTRAP_1/db/gtf/exons_start_mm10.gtf",
                "hg38" = "/groups/stark/vloubiere/projects/ORFTRAP_1/db/gtf/exons_start_hg38.gtf")
  genes <- rtracklayer::import(gtf)
  genes <- as.data.table(mcols(genes)[, c("gene_id", "gene_name")])
  genes <- unique(genes)
  setorderv(genes, "gene_id")

  # Main function to call hits ----
  main_function <- function(
    sorted.counts= sorted.forward.counts,
    unsorted.counts= unsorted.forward.counts,
    forward.counts= TRUE # Only set to TRUE when using forward counts!
  )
  {
    # Checks ----
    if(anyDuplicated(sorted.counts))
      stop("Duplicated filenames in sorted.counts")
    if(anyDuplicated(unsorted.counts))
      stop("Duplicated filenames in unsorted.counts")

    # Import counts ----
    input <- rbindlist(lapply(unsorted.counts, fread), idcol= "sample.idx")
    sample <- rbindlist(lapply(sorted.counts, fread), idcol= "sample.idx")
    dat <- rbindlist(list(count.input= input, count.sample= sample),
                     idcol= "cdition",
                     fill = T)
    dat[, sample.name:= paste0(cdition, ".", sample.idx)]
    dat[, sample.name:= factor(sample.name, unique(sample.name))]

    # Distance to closest exon ----
    if(forward.counts) # Boxplot only printed when using forwards counts!
    {

      # Initiate pdf
      pdf(output.pdf, 4.5, 4.5)

      # Plot
      vl_par()
      vl_boxplot(log10(dist+1)~sample.name,
                 dat,
                 ylab= "log10+(Distance to closest exon + 1)",
                 violin= T,
                 tilt.names = TRUE)
      leg <- dat[, paste0(sample.name, "= ", round(sum(dist<2e5, na.rm = T)/.N*100, 1), "%"), keyby= sample.name]
      vl_legend(legend = leg$V1, title= "Insertions < 2e5", x.adj = -2)

      # Cutoff abline
      abline(h= log10(2e5+1), lty= 3)
    }

    # Filter out distal insertions ----
    dat <- na.omit(dat[dist<2e5])

    # Filter duplication counts ----
    if(min.ins.cov.unsorted > 0 | min.ins.cov.sorted > 0) {
      if("ins_cov" %in% names(dat)) {

        # Plot DC density (only when using forwards counts!)
        if(forward.counts) {

          # Density plot
          Cc <- rainbow(length(unique(dat$sample.name)))
          dens <- dat[, density(log2(ins_cov+1))[c("x", "y")], keyby= sample.name]
          dens <- dens[, .(x= .(x), y= .(y), col= rainbow(.NGRP)[.GRP]), sample.name]
          plot(0,
               type= "n",
               xlim= range(unlist(dens$x)),
               ylim= range(unlist(dens$y)),
               xlab= "log2(insertions DC+1)",
               ylab= "Density")
          dens[, {
            lines(unlist(x), unlist(y), col= col[1], lwd= 2)
          }, .(sample.name, col)]

          # Legend
          vl_legend(legend= c(levels(dens$sample.name), "sorted.cutoff", "unsorted.cutoff"),
                    col= c(dens$col, "black", "red"),
                    lty= c(rep(1, length(dens$sample.name)), 3, 3),
                    x.adj = -2)

          # Add cutoff abline
          abline(v= log2(c(min.ins.cov.sorted, min.ins.cov.unsorted)+1),
                 lty= 3,
                 col= c("black", "red"))
        }

        # Filter out insertions with low DC ----
        dat <- dat[  (ins_cov >= min.ins.cov.unsorted & cdition == "count.input")
                     | (ins_cov >= min.ins.cov.sorted & cdition == "count.sample")]
      } else
        warning("ins_cov column is missing and DC cutoff will be skipped.")
    }

    # If not insertions left, stop here ----
    if(!nrow(dat))
      stop("No insertions left after distance/min.ins.cov cutoffs.")

    # Save bed files (only when using forward counts ----
    if(forward.counts) { # Only when using forwards counts!
      exportBed(dat[cdition=="count.sample" & strand=="+",
                    .(seqnames, start, end, name= make.unique(gene_name), score= ins_cov, strand)],
                file.path(bed.output.folder, "sample_insertions_ps.bed"))
      exportBed(dat[cdition=="count.sample" & strand=="-",
                    .(seqnames, start, end, name= make.unique(gene_name), score= ins_cov, strand)],
                file.path(bed.output.folder, "sample_insertions_ns.bed"))
      exportBed(dat[cdition=="count.input" & strand=="+",
                    .(seqnames, start, end, name= make.unique(gene_name), score= ins_cov, strand)],
                file.path(bed.output.folder, "input_insertions_ps.bed"))
      exportBed(dat[cdition=="count.input" & strand=="-",
                    .(seqnames, start, end, name= make.unique(gene_name), score= ins_cov, strand)],
                file.path(bed.output.folder, "input_insertions_ns.bed"))
    }

    # Count insertions per condition and per gene ----
    total <- dat[, .N, .(cdition)]
    dat <- dat[, .(count= .N), .(gene_id, cdition)]
    dat <- dcast(dat, gene_id~cdition, value.var = "count")

    # Format dat ----
    dat <- merge(genes, dat, by= "gene_id", all.x= T)
    dat[is.na(count.input), count.input:= 0]
    dat[is.na(count.sample), count.sample:= 0]
    dat[, total.input:= total[cdition=="count.input", N]]
    dat[, total.sample:= total[cdition=="count.sample", N]]

    # Fisher test sample vs input ----
    dat[count.sample >= 3, c("OR", "pval"):= {
      # Contingency matrix
      mat <- c(count.sample, total.sample-count.sample,
               count.input, total.input-count.input)
      mat <- matrix(mat, byrow = T, ncol = 2)
      # p.value
      .f <- fisher.test(mat, alternative = "greater")
      # log2OR (pseudocount avoid Inf)
      if(any(mat==0)) {
        mat <- mat+log2OR.pseudocount
        .f$estimate <- (mat[1,1] * mat[2,2]) / (mat[2,1] * mat[1,2])
      }
      .(.f$estimate, .f$p.value)
    }, .(count.input, total.input, count.sample, total.sample)]
    # Log OR and adjust pval
    dat[count.sample >= 3, log2OR:= log2(OR)]
    dat[count.sample >= 3, padj:= p.adjust(pval, "fdr")]
    dat[, hit:= padj <= padj.cutoff & log2OR >= log2OR.cutoff]

    # Clean table ----
    dat <- genes[dat, on= c("gene_id", "gene_name")]
    dat$OR <- dat$pval <- NULL

    # Volcano plot (only printed when using forward counts)----
    if(forward.counts) {
      pl <- dat[order(hit)]
      pl[, class:= fcase(hit, "Hit",
                         !is.na(padj), "N.S",
                         default = "NA")]
      pl[, class:= factor(class, c("Hit", "N.S", "NA"))]
      pl[, {
        vl_plot(log2OR,
                -log10(padj),
                col= ifelse(hit, "tomato", "lightgrey"),
                xlab= "Odd ratio (log2)",
                ylab= "FDR (-log10)")
        # Add hits labels
        if(any(hit, na.rm = T))
          .SD[(hit), {
            text(log2OR,
                 -log10(padj),
                 gene_name,
                 pos= 3,
                 cex= .5,
                 xpd= T)
          }]
      }]
      leg <- pl[, paste0(class, " (n= ", formatC(.N, big.mark = ","), ")"), keyby= class]
      vl_legend("topleft",
                legend= leg$V1,
                col= c("tomato", "lightgrey", NA),
                pch= 19)
      dev.off()
    }

    # Return
    return(dat)
  }

  # Compute hits (using forward insertions) ----
  res <- main_function()

  # Add comment for hits found using reversed insertion counts ----
  if(!is.null(sorted.reverse.counts) & !is.null(unsorted.reverse.counts)) {
    add <- main_function(sorted.counts = sorted.reverse.counts,
                         unsorted.counts = unsorted.reverse.counts,
                         forward.counts= F)
    add[, enriched.rev:= ifelse(hit, "Enriched for reversed integrations", NA_character_)]
    add <- add[, .(gene_id, enriched.rev, count.input, count.sample, total.input, total.sample)]
    res <- merge(res, add, by= "gene_id", all.x= T, suffixes= c("", ".rev"))
  }

  # Save ----
  fwrite(res,
         output.file,
         col.names = T,
         row.names = F,
         sep= "\t",
         quote= F,
         na= NA)
  cat(paste0(output.prefix, ": ", sum(res$hit, na.rm = T), " hits were called!\nFC file -> ", output.file, "\nPDF -> ", output.pdf, "\nBED insertions -> ", bed.output.folder, "\n"))
}
