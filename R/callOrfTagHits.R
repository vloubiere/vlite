#' ORFtrap_call_hits
#'
#' @description Function to call hits from a given screen. Receives sorted and unsorted counts as input, computes FC table
#'
#' @param sorted.forward.counts Character vector of sorted (FACSed) count file paths generated by vl_ORFtag_pipeline().
#' Counts from all provided files will be merged.
#' @param unsorted.forward.counts Character vector of unsorted (input) count file paths generated by vl_ORFtag_pipeline().
#' Counts from all provided files will be merged.
#' @param genome Genome annotation to be used.
#' For now, only "mm10" and "hg38" are supported, and the corresponding non-first-exon .gtf will be used for sorting.
#' @param output.prefix Prefix used for output file names.
#' @param padj.cutoff The p.adjust cutoff to be used to call hits (>=). Default= 0.001
#' @param log2OR.cutoff The log2OR cutoff to be used to call hits (>=). Default= 1
#' @param log2OR.pseudocount Pseudocount used to avoid infinite values. Note that only the log2OR will be affected, not the fisher p.values. Default= 1.
#' @param min.ins.cov.unsorted Minimum number of duplication counts for an insertion to be considered TRUE in the unsorted sample.
#' Default= 0 (no filtering).
#' @param min.ins.cov.sorted Minimum number of duplication counts for an insertion to be considered TRUE in the sorted sample.
#' Default= 0 (no filtering).
#' @param output.folder Output folder for FC files. Default= "db/FC_tables/ORFtag".
#'
#' @return Returns FC tables containing DESeq2-like columns.
#'
#' @examples
#' # Call hits ----
#' # 124 hits should be identified with this dataset
#' callOrftagHits(sorted.forward.counts = c("db/exon_assignment/ORFtag/Activator2_sort_rep1_same_strand.txt",
#'                                                "db/exon_assignment/ORFtag/Activator2_sort_rep2_same_strand.txt"),
#'                      unsorted.forward.counts = c("db/exon_assignment/ORFtag/Activator2_input_rep1_same_strand.txt",
#'                                                  "db/exon_assignment/ORFtag/Activator2_input_rep2_same_strand.txt"),
#'                      genome = "mm10",
#'                      output.prefix = "Activator_2_vs_input")
#'
#' # Call hits using revese strand (sanity check -> be cautious with the hits that are also found here!) ----
#' # 81 hits should be identified with the reverse strand
#' callOrftagHits(sorted.forward.counts = c("db/exon_assignment/ORFtag/Activator2_sort_rep1_rev_strand.txt",
#'                                                "db/exon_assignment/ORFtag/Activator2_sort_rep2_rev_strand.txt"),
#'                      unsorted.forward.counts = c("db/exon_assignment/ORFtag/Activator2_input_rep1_rev_strand.txt",
#'                                                  "db/exon_assignment/ORFtag/Activator2_input_rep2_rev_strand.txt"),
#'                      genome = "mm10",
#'                      output.prefix = "Activator_2_vs_input_rev_strand")
#'
#' # 4 of the hits should be identified with the reverse strand and should be considered carefully
#' hits <- fread("db/FC_tables/ORFtag/Activator_2_vs_input.txt")[(hit), gene_name]
#' sanityCheck <- fread("db/FC_tables/ORFtag/Activator_2_vs_input_rev_strand.txt")[(hit), gene_name]
#'
#' # Hits to be considered carefully:
#' intersect(hits, sanityCheck)
#'
#' # To call hits using strand bias (not used)
#' see ?callOrftagHits_strandBias()
#'
#' @export
callOrftagHits <- function(sorted.forward.counts,
                           unsorted.forward.counts,
                           genome,
                           output.prefix,
                           padj.cutoff= 0.001,
                           log2OR.cutoff= 1,
                           log2OR.pseudocount= 1,
                           min.ins.cov.sorted= 0,
                           min.ins.cov.unsorted= 0,
                           output.folder= "db/FC_tables/ORFtag/")
{
  require(rtracklayer)
  require(data.table)
  require(GenomicRanges)

  # Checks ----
  if(!is.character(output.prefix) | length(output.prefix)!=1)
    stop("output.prefix should be a unique character, typically the name of the screen + comparison.")
  if(anyDuplicated(sorted.forward.counts))
    stop("Duplicated filenames in sorted.forward.counts")
  if(anyDuplicated(unsorted.forward.counts))
    stop("Duplicated filenames in unsorted.forward.counts")

  # Import counts ----
  input <- rbindlist(lapply(unsorted.forward.counts, fread), idcol= "sample.idx")
  sample <- rbindlist(lapply(sorted.forward.counts, fread), idcol= "sample.idx")
  dat <- rbindlist(list(count.input= input, count.sample= sample),
                   idcol= "cdition",
                   fill = T)
  dat[, sample.name:= paste0(cdition, ".", sample.idx)]
  dat[, sample.name:= factor(sample.name, unique(sample.name))]

  # Output file names ----
  dir.create(output.folder, showWarnings = F, recursive = T)
  output.file <- file.path(output.folder, paste0(output.prefix, ".txt"))
  output.pdf <- file.path(output.folder, paste0(output.prefix, ".pdf"))

  # Distance cutoff ----
  # Initiate pdf
  pdf(output.pdf, 4.5, 4.5)
  # Plot
  vl_par()
  vl_boxplot(log10(dist+1)~sample.name,
             dat,
             ylab= "log10+(Distance to closest exon + 1)",
             violin= T,
             tilt.names = TRUE)
  leg <- dat[, paste0(sample.name, "= ", round(sum(dist<2e5, na.rm = T)/.N*100, 1), "%"), keyby= sample.name]
  vl_legend(legend = leg$V1,
            title= "Insertions < 2e5",
            x.adj = -2)
  # Cutoff
  abline(h= log10(2e5+1),
         lty= 3)
  # Filtering
  dat <- na.omit(dat[dist<2e5])

  # Filtering duplication counts ----
  if(min.ins.cov.unsorted>0 | min.ins.cov.sorted>0) {
    if(!"ins_cov" %in% names(dat)) {
      warning("min.ins.cov is provided but 'ins_cov' is missing -> filtering step is skipped.")
    } else {
      # Plot
      Cc <- rainbow(length(unique(dat$sample.name)))
      dens <- dat[, density(log2(ins_cov+1))[c("x", "y")], keyby= sample.name]
      dens <- dens[, .(x= .(x), y= .(y), col= rainbow(.NGRP)[.GRP]), sample.name]
      plot(0,
           type= "n",
           xlim= range(unlist(dens$x)),
           ylim= range(unlist(dens$y)),
           xlab= "log2(insertions DC+1)",
           ylab= "Density")
      dens[, {
        lines(unlist(x), unlist(y), col= col[1], lwd= 2)
      }, .(sample.name, col)]
      vl_legend(legend= c(levels(dens$sample.name), "sorted.cutoff", "unsorted.cutoff"),
                col= c(dens$col, "black", "red"),
                lty= c(rep(1, length(dens$sample.name)), 3, 3),
                x.adj = -2)
      # Cutoff
      abline(v= log2(c(min.ins.cov.sorted, min.ins.cov.unsorted)+1),
             lty= 3,
             col= c("black", "red"))
      # Filtering
      dat <- dat[(ins_cov>=min.ins.cov.unsorted & cdition=="count.input")
                 | (ins_cov>=min.ins.cov.sorted & cdition=="count.sample")]
      if(!nrow(dat))
        stop("No insertions left after min.ins.cov cutoffs.")
    }
  }

  # Count insertions per condition and per gene ----
  total <- dat[, .N, .(cdition)]
  dat <- dat[, .(count= .N), .(gene_id, cdition)]
  dat <- dcast(dat, gene_id~cdition, value.var = "count")

  # Import gene exons ----
  gtf <- switch(genome,
                "mm10" = "/groups/stark/vloubiere/projects/ORFTRAP_1/db/gtf/exons_start_mm10.gtf",
                "hg38" = "/groups/stark/vloubiere/projects/ORFTRAP_1/db/gtf/exons_start_hg38.gtf")
  genes <- rtracklayer::import(gtf)
  genes <- as.data.table(mcols(genes)[, c("gene_id", "gene_name")])
  genes <- unique(genes)
  setorderv(genes, "gene_id")

  # Format dat ----
  dat <- merge(genes, dat, by= "gene_id", all.x= T)
  dat[is.na(count.input), count.input:= 0]
  dat[is.na(count.sample), count.sample:= 0]
  dat[, total.input:= total[cdition=="count.input", N]]
  dat[, total.sample:= total[cdition=="count.sample", N]]

  # Fisher test sample vs input ----
  dat[count.sample>=3, c("OR", "pval"):= {
    .t <- matrix(c(total.input-count.input,
                   count.input,
                   total.sample-count.sample,
                   count.sample),
                 ncol= 2)
    .(fisher.test(.t+log2OR.pseudocount, alternative = "greater")$estimate,
      fisher.test(.t, alternative = "greater")$p.value)
  }, .(count.input, total.input, count.sample, total.sample)]
  dat[count.sample>=3, log2OR:= log2(OR)]
  dat[count.sample>=3, padj:= p.adjust(pval, "fdr")]
  dat[, hit:= padj<=padj.cutoff & log2OR>=log2OR.cutoff]
  # Clean table
  dat <- genes[dat, on= c("gene_id", "gene_name")]
  dat$OR <- dat$pval <- NULL

  # Volcano plot ----
  pl <- dat[order(hit)]
  pl[, class:= fcase(hit, "Hit",
                     !is.na(padj), "N.S",
                     default = "NA")]
  pl[, {
    vl_plot(log2OR,
            -log10(padj),
            col= ifelse(hit, "tomato", "lightgrey"),
            xlab= "Odd ratio (log2)",
            ylab= "FDR (-log10)")
    .SD[(hit), {
      text(log2OR,
           -log10(padj),
           gene_name,
           pos= 3,
           cex= .5,
           xpd= T)
    }]
  }]
  leg <- pl[, paste0(class, " (n= ", formatC(.N, big.mark = ","), ")"), class]
  vl_legend("topleft",
            legend= leg$V1,
            col= c("tomato", "lightgrey", NA),
            pch= 19)
  dev.off()

  # Save ----
  fwrite(dat,
         output.file,
         col.names = T,
         row.names = F,
         sep= "\t",
         quote= F,
         na= NA)
  cat(paste0(output.prefix, ": ", sum(dat$hit, na.rm = T), " hits were called!\nFC file -> ", output.file, "\nPDF -> ", output.pdf, "\n"))
}
